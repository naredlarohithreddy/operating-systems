breakpoint;
[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=-1; // indicating exception handler mode
alias userSP R11;
userSP=SP;
[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13]=SP;
SP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+11]*512-1;
backup;
multipush(EIP);
if(EC!=0) then 
    if(EC==1) then
        print "Illegal Instruction";
        R1=3; //exit process
        R2=[SYSTEM_STATUS_TABLE+1];
        call PROCESS_MANAGER;
        call SCHEDULER;
    endif;
    if(EC==2) then
        print "Illegal Memory Access";
        R1=3; //exit process
        R2=[SYSTEM_STATUS_TABLE+1];
        call PROCESS_MANAGER;
        call SCHEDULER;
    endif;
    if(EC==3) then
        print "Arithmetic Exception";
        R1=3; //exit process
        R2=[SYSTEM_STATUS_TABLE+1];
        call PROCESS_MANAGER;
        call SCHEDULER;
    endif;
endif;
if(EC==0) then
//page fault
    if((EPN>=4)&&(EPN<=7)) then //code page
        alias codeBlockNum R1;
        codeBlockNum = [DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+EPN];
        multipush(R0,R1);
        R2=codeBlockNum;
        R1=5; //get code page
        call MEMORY_MANAGER;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+2*EPN]=R0;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+2*EPN+1]="1100";
        multipop(R0,R1);
    endif;
    if((EPN>=2)&&(EPN<=3)) then //heap page
        print "heap";
        multipush(R0,R1);
        R1=1; //get free page
        call MEMORY_MANAGER;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+4]=R0;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+5]="1110";
        R1=1; //get free page
        call MEMORY_MANAGER;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+6]=R0;
        [[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+14]+7]="1110";
        multipop(R0,R1);
    endif;
    [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=0;
    multipop(EIP);
    restore;
    SP=userSP+1;
    [[PTBR+2*(SP/512)]*512+(SP%512)]=EIP;
    ireturn;
endif;